% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/score_bayesian.R
\name{score_bayesian}
\alias{score_bayesian}
\title{Computing Model Scores as Posterior Probabilities using Bayesian Inference}
\usage{
score_bayesian(m, sigma = NULL)
}
\arguments{
\item{m}{A Matrix of values. The first column of the matrix should be
a vector of observed data for a give variable. Subsequent vectors should be
representative of modeled values for a given variable.}

\item{sigma}{Numeric value (optional). The standard deviation parameter for
the normal distribution used in the Bayesian analysis. If not provided, the
function will automatically compute it as the standard deviation of the
Root Mean Square Error (RMSE). A smaller value of `sigma` will make the
Bayesian analysis give more weight to models with lower RMSE values.
On the other hand, a larger value of `sigma` will distribute the weight more
evenly among different models, expressing less certainty about the model
selection. Users may choose to provide their own value for `sigma` based on
their prior beliefs or domain knowledge.}
}
\value{
Returns a vector of scores with a length equal to the number of
model iterations in the input matrix. Or, if the input matrix has K columns,
the return vector will = K - 1.
}
\description{
This function uses observed data to compute scores that represent
how well modeled values reflect what is occurring in reality. To do this, the
function uses root mean square error (RMSE) values to compute the likelihood
of observing modeled values given observed values, assuming normal distribution
of errors. Likelihood values are used to compute posterior probabilities which
are used as scores for each model iteration.
}
\note{
Note: In Bayesian statistics, the choice of `sigma` can significantly
impact the results and conclusions of the analysis. Users are encouraged to
experiment with different values and understand the implications for their
specific use case.
}
\examples{
# creating sample matrix
mat <- matrix(data = 1:15, nrow = 5, ncol = 3)

# scoring with a decay rate of 2
score_bayesian(mat, sigma = 2)
}
